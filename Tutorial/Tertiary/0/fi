/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  6                                     |
|   \\  /    A nd           | Web:      http://www.OpenFOAM.org               |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       volScalarField;
    object      fi;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
#include "include/controlProperties"

dimensions      [1 2 -3 0 0 -1 0];// V = kg*m^2/(A*s^3)

internalField   uniform	#calc "($ref+$maxPot)/2";

boundaryField
{
    "wall_.*"       
    {
        type            zeroGradient;
    }

    wall_anode       
    {

/*   type	fixedGradient;
    gradient	uniform 0.77519; //j/kappa
*/
    type            codedMixed;
    
    refValue        uniform #calc "($maxPot-$ref)";//$internalField;//
    refGradient     uniform 0;
    valueFraction   uniform 1;

    name    anode_fi;   // name of generated BC

    code
    #{
        const fvPatch& p = this->patch();                                                                          // Actual boundary/patch
    	label patchID = p.patch().boundaryMesh().findPatchID("wall_anode");                                       // Desired patch ID
        const fvMesh& mesh = patch().boundaryMesh().mesh();

        
        const volScalarField& kf_ = this->db().objectRegistry::template lookupObject<volScalarField>("keff");   // Desired field 1
        const volScalarField& fi_ = this->db().objectRegistry::template lookupObject<volScalarField>("fi"); // Desired field 2
        const volScalarField& Con_red = this->db().objectRegistry::template lookupObject<volScalarField>("C_red");   // Desired field 3
        const volScalarField& Con_ox = this->db().objectRegistry::template lookupObject<volScalarField>("C_ox");

        const scalarField& kf_boundary = kf_.boundaryField()[patchID];                                              // Desired field on desired patch
        const scalarField& fi_boundary = fi_.boundaryField()[patchID];                                            // Desired field on desired patch
        const scalarField& C_red_boundary = Con_red.boundaryField()[patchID];                             // Desired field on desired patch
	const scalarField& C_ox_boundary = Con_ox.boundaryField()[patchID]; 
        
        scalarField delta = 1.0/mesh.deltaCoeffs().boundaryField()[patchID]; 

        const dictionary& kineticProperties = db().lookupObject<IOdictionary>("transportProperties");
        const dictionary& Results = db().lookupObject<IOdictionary>("Results");
        
        
        scalar j0_Ni = readScalar(kineticProperties.lookup("j0_Ni")); 
        scalar ba_Ni = readScalar(kineticProperties.lookup("ba_Ni"));
       	scalar bc_Ni = readScalar(kineticProperties.lookup("bc_Ni"));
	scalar j0_O2= readScalar(kineticProperties.lookup("j0_O2"));
        scalar ba_O2 = readScalar(kineticProperties.lookup("ba_O2"));
	scalar E0_O2 = readScalar(kineticProperties.lookup("E0_O2"));

        scalar C_redinf = readScalar(kineticProperties.lookup("C_redinf")) ;
	scalar C_oxinf = readScalar(kineticProperties.lookup("C_oxinf")) ;

        scalar Vcell = readScalar(Results.lookup("Vcell"));
 
        scalarField jota1 = j0_Ni*C_red_boundary/C_redinf*exp((Vcell-fi_boundary)/ba_Ni);                    
        scalarField jota2 = -j0_Ni*C_ox_boundary/C_oxinf*exp((Vcell-fi_boundary)/bc_Ni);
	scalarField jota3 = j0_O2*exp((Vcell-fi_boundary-E0_O2)/ba_O2);
	scalarField k0 = kf_boundary/delta;
                                                         
        scalarField A = (1/k0)*(jota1/ba_Ni+jota2/bc_Ni+jota3/ba_O2);                            
	scalarField B = (1/k0)*((1+fi_boundary/ba_Ni)*jota1+(1+fi_boundary/bc_Ni)*jota2+(1+fi_boundary/ba_O2)*jota3); 
         
        this->refValue() = B/A;
        this->refGrad() = 0;
        this->valueFraction() = A/(A+1); 
    #};
 
    codeInclude
    #{
        #include "fvCFD.H"
        #include "fvcSnGrad.H"
    #};

    codeOptions
    #{
        -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(LIB_SRC)/meshTools/lnInclude
    #};

    }

    wall_cathode      
    {

    type            codedMixed;
    
    refValue        uniform $ref;//$internalField;//
    refGradient     uniform 0;
    valueFraction   uniform 1;

    name    cathode_fi;   // name of generated BC

    code
    #{
        const fvPatch& p = this->patch();                                                                          // Actual boundary/patch
    	label patchID = p.patch().boundaryMesh().findPatchID("wall_cathode");                                       // Desired patch ID
        const fvMesh& mesh = patch().boundaryMesh().mesh();

        const volScalarField& kf_ = this->db().objectRegistry::template lookupObject<volScalarField>("keff");   // Desired field 1
        const volScalarField& fi_ = this->db().objectRegistry::template lookupObject<volScalarField>("fi"); // Desired field 2
        const volScalarField& Con_ox = this->db().objectRegistry::template lookupObject<volScalarField>("C_ox");   // Desired field 3
        
        const scalarField& kf_boundary = kf_.boundaryField()[patchID];                                              // Desired field on desired patch
        const scalarField& fi_boundary = fi_.boundaryField()[patchID];                                            // Desired field on desired patch
        const scalarField& C_ox_boundary = Con_ox.boundaryField()[patchID];                                              // Desired field on desired patch

        scalarField delta = 1.0/mesh.deltaCoeffs().boundaryField()[patchID]; 

        const dictionary& kineticProperties = db().lookupObject<IOdictionary>("transportProperties");
  
        
        scalar j0_SS316 = readScalar(kineticProperties.lookup("j0_SS316"));
        scalar bc_SS316 = readScalar(kineticProperties.lookup("bc_SS316"));
	scalar ba_SS316 = readScalar(kineticProperties.lookup("ba_SS316"));
        scalar j0_H2 = readScalar(kineticProperties.lookup("j0_H2"));
        scalar bc_H2 = readScalar(kineticProperties.lookup("bc_H2"));
        scalar E0_H2 = readScalar(kineticProperties.lookup("E0_H2"));
	
	scalar C_oxinf = readScalar(kineticProperties.lookup("C_oxinf"));
 
        scalarField jota1 = -j0_SS316*C_ox_boundary/C_oxinf*exp((-fi_boundary)/bc_SS316);                                                        
        scalarField jota2 = j0_SS316*exp((-fi_boundary)/ba_SS316);
	scalarField jota3 = j0_H2*exp((-fi_boundary-E0_H2)/bc_H2);
        scalarField k0 = kf_boundary/delta;                                                                      
        
	scalarField A = (1/k0)*(jota1/bc_SS316+jota2/ba_SS316+jota3/bc_H2);       
	scalarField B = (1/k0)*((1+fi_boundary/bc_SS316)*jota1+(1+fi_boundary/ba_SS316)*jota2+(1+fi_boundary/bc_H2)*jota3); 
        
	this->refValue() = B/A;
        this->refGrad() = 0;
        this->valueFraction() = A/(A+1); 
    #};
 
    codeInclude
    #{
        #include "fvCFD.H"
        #include "fvcSnGrad.H"
    #};

    codeOptions
    #{
        -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(LIB_SRC)/meshTools/lnInclude
    #};


    }  
    outlet
    {
        type            zeroGradient;
    }
    inlet
    {
	type            zeroGradient;
    }   
    frontAndBack
    {
        type            empty;   
    }  
}

// ************************************************************************* //
